#+TITLE: Bellini's LabBook
#+AUTHOR: Lucas e Tais
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Lucas(L) Tais(T) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* 2015-09-15 Planning                                            :Lucas:Tais:

|---------+--------------------------------------------------|
| Sep/Oct | Complete Java Simulator for the Paje file format |
| Nov/Dec | Database modeling for Paje traces                |
| Jan/Feb | Experimentation and Performance Evaluation       |
| Mar/Jun | Write the thesis                                 |
|---------+--------------------------------------------------|

* 2015-09-15 Structure / Draft of TCC                            :Lucas:Tais:

1. Introduction (3 pages max)
   + Context (current scenario with pajeng c++)
   + Motivation
2. Basic Concepts? (5 pages max)
   + JavaCC?
   + Ferramentas de an√°lise de desempenho
3. PajeNG
   + How it is used by others (pjdump, etc)
   + Description of how it works internally
   + The problems with the current approach
     + Focus on your contribution
4. Java Simulator
   + JavaCC / Perf. Eval. against others / Why JavaCC?
5. Database modeling
6. Perf. Eval. / Experimentation / Results
7. Conclusion
* 2016-02-15 Performance issues                                  :Lucas:Tais:

Tais report that her solution to DB insertion has severe performance
issues. The initial solution was that every *pop* event become a
insert. That didn't work, so Tais optimize with an alternative
implementation which uses StringBuffer and create many insert commands
on that object. They only get executed at the end of the parsing. Tais
was never capable to evaluate if this solution is faster because
execution runs out of memory.

So, by looking into this SO entry:

+ http://stackoverflow.com/questions/11389449/performance-of-mysql-insert-statements-in-java-batch-mode-prepared-statements-v

We propose a new attempt to solve the performance problem. The SO
entry proposes four solutions, we will take the last one, which seems
the best. To correctly adapt this fourth solution to Tais's case, we
should limit the batch size to something acceptable. If not, we will
run out of memory again because the (usual) trace file size is just
too big.

So, next plans are like this:
- Tais will limit the size of the batch considering the number of
  operations on it.
- Each batch will contain five StringBuffers, one for each paje type
  (Container, State, Link, Variable, and Event).
- Every time something gets added to one of these string buffers, the
  operation count of the batch gets increased.
- When the batch size reaches a (configurable) value X, the code
  executes the batch, zero it, and we start again filling.
- Tais will do a quick performance analysis by changing the
  (configurable) value X to see the impact in execution time.

How to know the baseline:
- Find out how long it take to only parse with the Java version. You
  can do that by checking out the *no-db* branch.


* 2016-02-26 Meeting with Tais                                   :Lucas:Tais:

How to get it working.

Install mysql, root password should be root:

#+begin_src sh :results output :session :exports both
sudo apt-get install mysql-server
#+end_src

Run the =pajeDB.sql= to create the tables.

Fix =compile.sh= to have the correct CLASSPATH.

Problems found:
- Program does not terminate
- 


_Plugin_:

- Today, SQL commands are created in the middle of the PajeSimulator
  source code. Moreover, the different strategies (searching for
  performance) are commented in the same source code. This leads to
  design that is difficult to manage, and also hard to evaluate the
  different performance options.

- So my suggestion is to create a plugin for each type of output from
  the simulator. You will go back in time so the Paje Simulator source
  code is as clean as possible, and instrument this code to contain
  specific calls when something should be registered (such as the pop,
  the end links, and so on).

- The plugin will be called in this different instrumentation points
  and do what it was design to do. A first plugin to be implemented is
  the one with the SQL insert commands.

- Alternative versions to look for better performance should be
  implemented as other plugins, that could be subclasses (derived)
  from the initial one, if there is some functionality sharing between
  them.

- Plugins already proposed by Tais:
  - Multiple batches, but are handle sequentially
  - Multiple batches, but with threads
  - Print the SQL commands to output

- Class model for this plugin story
  - PajePlugin
    - PajePluginMultipleBatchesSequential
      - PajePluginMultipleBatchesThreads
    - PajePluginPrintSQLCommandsToOutput
    - PajePluginNull
    - PajePluginOutputPJDUMP

- Clean PajeSimulator
  - Create PajePlugin

- Exhaustive list of instrumentations points for the plugins
  - All types and values definitions
  - All create containers
  - Pops
  - Events
  - Add, Sub, Set variables
  - Start and end of links

* 2016-02-28 Starting Aiyra                                            :Tais:
The new implementation with plugins will be called Aiyra.
The code is [[https://github.com/taisbellini/aiyra][here]].
There are only two classes with a print informing which plugin was chosen.

** How to use

#+begin_src sh :results output :session :exports both
java br.ufrgs.inf.tlbellini.PajeGrammar -f <path-to-trace-file> \
                                        -m <comment (optional)> \
                                        -p <plugin (default: null)> \
                                        - ... <options for the specific plugin>
#+end_src

** Plugins available

- "pjdump": it outputs a CSV based on the =pj_dump= format
- "mysql" : saves the data in a MySQL database

** References
Command line reader:
http://www.javaworld.com/article/2074849/core-java/processing-command-line-arguments-in-java--case-closed.html
** Performance
commit: "create poc of integration of plugins and the Options package"
- scorep-cg.A.64.paje - 2.1GB - 367918ms
- scorep-lu.B.64.paje - 776.7MB - 77917ms
- traces-16Mega.paje - 16MB - 1500ms


** Plugins
PajeDumpPlugin: using System.out.println which is bad in performance,
but I couldn't find other solution that would not giva e heap space
problem to big files. The current solution implies the user to decide
how many lines will be in the dump. The higher the number, better the
performance but more memory is used. In my computer, I have
JavaHeapSpace problem. 


* 2016-02-29 Adding PajeInsertDBPlugin                                 :Tais:
** Notes
-When destroy container: just need to insert states
    - Event: inserts when it happens
    - Var: inserts when it is created or updated
    - Link: inserts when it is complete
* 2016-03-15 How to Use 
** DB Plugin 

1) Install MySQL and MySQL Workbench 

2) Create an instance (local or in a server) and choose a name and password to it. Use port 3306. 

3) execute pajeDB.sql script in the created instance.

Now you have a database called "paje". 

Execute the simulator passing the server name (-s) name (-u) and password (-pwd) of the instance you created in step 2. Defaults are "localhost", "root", "root". 


#+begin_src sh :results output :session :exports both
java br.ufrgs.inf.tlbellini.PajeGrammar -f <path-to-trace-file> \
                                        -m <comment (optional)> \
                                        -p mysql \
                                        -s <server-name> \
                                        -u <username> \
                                        -pwd <password> \
#+end_src

** PajeDump Plugin

Execute:

#+begin_src sh :results output :session :exports both
java br.ufrgs.inf.tlbellini.PajeGrammar -f <path-to-trace-file> \
                                        -m <comment (optional)> \
                                        -p pjdump \
                                        -l <lines-per-dump (default: 100000)>
#+end_src

"lines-per-dump" is the number of lines that will be printed each time. Higher numbers takes less time but use more memory. 

* 2016-03-15 - How to Create a Plugin
In order to create a new plugin you'll need to: 
MODIFY OptionsHandler.java in br.ufrgs.inf.tlbellini;
CREATE a NEW class in br.ufrgs.inf.tlbellini.plugins that EXTENDS PajePlugin class. It can also extend any other plugin if they have many similarities. 

MODIFY OptionsHandler:
1) *If your plugin DOES NOT NEED an extra argument, SKIP this instruction*

In the OptionsHandler constructor, add the new argument as follows: 
  
   opt.getSet().addOptions("<alias>", Options.Separator.<SEPARATOR>, Options.Multiplicity.<MULTIPLICITY>);

   <alias> = the alias to identify the argument
   <SEPARATOR> = COLON, EQUALS, BLANK, NONE
   <MULTIPLICITY> = ONCE, ONCE_OR_MORE, ZERO_OR_ONE, ZERO_OR_MORE

2) Explain your new entry (if any) and plugin in printOptionsHelper() method.
3) In pluginHandler() method, add a "case" to your plugin. Make all the assignments you need to do and initialize it. 
   to get the value given for the argument: 
     opt.getSet().getOption("<alias").getResultValue(0)
   to check if the value was set: 
     opt.getSet().isSet("<alias>")
   to initialize:
     PajeGrammar.plugin = new YourPluginClass(...);

CREATE NEW CLASS: 

1) Create a class that extends PajePlugin or any Plugin available. 
   
Instrumentation Points:

* 2016-03-29 Meeting with Tais

Performance Evalution

- DB Insertion Plugin
  - _Multiple batches, but are handle sequentially_

- What is the experimental configuration?
  - Software and hardware
  - Software: everything in the same machine

_What we shall measure to evaluate?_

- *Batch size*
  - Input size
    - Lucas will provide a trace file generator
      128K, 128M, 1G
  - Batch size in operations
    - 128
    - 256
    - 512
    - 1024
    - 2048
    - ...
  - Four platform configurations
    - _luiza_ Tais' personal notebook (Local/Mac) - Tais
    - _guarani_ Lucas' guarani (Linux/Local) - Lucas
    - _orion_ Orion (Linux/Local) - Tais
    - _hptais_ Tais' work notebook is client (Windows), guarani is server (Linux) (Remote) - Tais
      - Find out the interconnection topology
      - The latency and the bandwidth of the network (limits)
        - Find out a metric to see if you reach the network limit

- What to measure
  - Global execution time
    - Only simulation
    - Only insertion
  - Global memory occupation
  |----------------------+---------------------+--------------------------|
  | Only Simulation Time | Only Insertion Time | Global Memory Occupation |
  |----------------------+---------------------+--------------------------|

  - How batches have been generated
    - When a batch has started, when it has ended
    - Format suggestion for dumping this kind of information
      |--------------+------------+----------+---------------+------------------------------|
      | Batch number | Start time | End time | Size in bytes | Size in number of operations |
      |--------------+------------+----------+---------------+------------------------------|

- *Comparison against C++*
  - Measure only the simulation time
    - Null plugin against
      - =pj_dump= with =-q=
      - =pj_dump= with =-q= and =-f= (for flex)
  - Input size
    -  128K, 128M, 1G
  - _Platforms_
    - Tais' personal notebook (Local) - Tais
    - Lucas' guarani (Local) - Lucas
    - Orion (Local) - Tais
  |----------------------|
  | Only simulation time |
  |----------------------|

_Experimental Design_

- How many replications? 30.
- Statistical framework: gaussian distribution, with mean, sd, se
  - se: =3*sd/sqrt(n)=, CI of 99.7% assuming gaussian
  - no statistical tests (t-test), because we'll use plots to analyze
    with mean+se and mean-se
- See Jain 1992, Part III, Chapter 16.

- _Factors_
  - Input size
    - small, big
  - Batch size
    - small, big
  - Platform
    - two platforms wildly different

- _Real Factors and levels_ (see chapter 23 on page 381)
  - input size: 3
  - batch size: 6
  - platforms: 4
- 3*6*4
  #+begin_src R :results output :session :exports both
  input_size = 3;
  batch_levels = 6;
  platforms = 4;
  r=30;
  total_number_of_experiments = input_size*batch_levels*platforms*r
  minutes_each = 15;
  total_number_of_experiments * minutes_each / 60 / 24
  #+end_src

  #+RESULTS:
  : [1] 22.5

_C++ Comparison Analysis_

- Version
  - Ayira
  - pajeng with flex
  - pajeng without flex
- Input size
- 30 replications

|------------+---------|
| Input Size | Version |
|------------+---------|

_Changes to the *mysql* plugin_
- add a new parameter to tell the batch size (default is size of input)
- add a flag (disable by default) to tell the plugin to measure each batch execution
  - a vector will be used to keep this in memory during execution;
    only at the end that this is dumped to CSV
  - generates a new file that has the CSV info in the beggining of
    each line and then the following information you have measured
  |--------------+------------+----------+---------------+------------------------------|
  | Batch number | Start time | End time | Size in bytes | Size in number of operations |
  |--------------+------------+----------+---------------+------------------------------|

_How to measure memory utilization_
- MemoryUsage class in Java, check the used() method
- Compare against top (the column that indicates the virtual memory allocated)
