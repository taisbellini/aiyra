#+TITLE: Bellini's LabBook
#+AUTHOR: Lucas e Tais
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Lucas(L) Tais(T) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

* 2015-09-15 Planning                                            :Lucas:Tais:

|---------+--------------------------------------------------|
| Sep/Oct | Complete Java Simulator for the Paje file format |
| Nov/Dec | Database modeling for Paje traces                |
| Jan/Feb | Experimentation and Performance Evaluation       |
| Mar/Jun | Write the thesis                                 |
|---------+--------------------------------------------------|

* 2015-09-15 Structure / Draft of TCC                            :Lucas:Tais:

1. Introduction (3 pages max)
   + Context (current scenario with pajeng c++)
   + Motivation
2. Basic Concepts? (5 pages max)
   + JavaCC?
   + Ferramentas de an√°lise de desempenho
3. PajeNG
   + How it is used by others (pjdump, etc)
   + Description of how it works internally
   + The problems with the current approach
     + Focus on your contribution
4. Java Simulator
   + JavaCC / Perf. Eval. against others / Why JavaCC?
5. Database modeling
6. Perf. Eval. / Experimentation / Results
7. Conclusion
* 2016-02-15 Performance issues                                  :Lucas:Tais:

Tais report that her solution to DB insertion has severe performance
issues. The initial solution was that every *pop* event become a
insert. That didn't work, so Tais optimize with an alternative
implementation which uses StringBuffer and create many insert commands
on that object. They only get executed at the end of the parsing. Tais
was never capable to evaluate if this solution is faster because
execution runs out of memory.

So, by looking into this SO entry:

+ http://stackoverflow.com/questions/11389449/performance-of-mysql-insert-statements-in-java-batch-mode-prepared-statements-v

We propose a new attempt to solve the performance problem. The SO
entry proposes four solutions, we will take the last one, which seems
the best. To correctly adapt this fourth solution to Tais's case, we
should limit the batch size to something acceptable. If not, we will
run out of memory again because the (usual) trace file size is just
too big.

So, next plans are like this:
- Tais will limit the size of the batch considering the number of
  operations on it.
- Each batch will contain five StringBuffers, one for each paje type
  (Container, State, Link, Variable, and Event).
- Every time something gets added to one of these string buffers, the
  operation count of the batch gets increased.
- When the batch size reaches a (configurable) value X, the code
  executes the batch, zero it, and we start again filling.
- Tais will do a quick performance analysis by changing the
  (configurable) value X to see the impact in execution time.

How to know the baseline:
- Find out how long it take to only parse with the Java version. You
  can do that by checking out the *no-db* branch.


* 2016-02-26 Meeting with Tais                                   :Lucas:Tais:

How to get it working.

Install mysql, root password should be root:

#+begin_src sh :results output :session :exports both
sudo apt-get install mysql-server
#+end_src

Run the =pajeDB.sql= to create the tables.

Fix =compile.sh= to have the correct CLASSPATH.

Problems found:
- Program does not terminate
- 


_Plugin_:

- Today, SQL commands are created in the middle of the PajeSimulator
  source code. Moreover, the different strategies (searching for
  performance) are commented in the same source code. This leads to
  design that is difficult to manage, and also hard to evaluate the
  different performance options.

- So my suggestion is to create a plugin for each type of output from
  the simulator. You will go back in time so the Paje Simulator source
  code is as clean as possible, and instrument this code to contain
  specific calls when something should be registered (such as the pop,
  the end links, and so on).

- The plugin will be called in this different instrumentation points
  and do what it was design to do. A first plugin to be implemented is
  the one with the SQL insert commands.

- Alternative versions to look for better performance should be
  implemented as other plugins, that could be subclasses (derived)
  from the initial one, if there is some functionality sharing between
  them.

- Plugins already proposed by Tais:
  - Multiple batches, but are handle sequentially
  - Multiple batches, but with threads
  - Print the SQL commands to output

- Class model for this plugin story
  - PajePlugin
    - PajePluginMultipleBatchesSequential
      - PajePluginMultipleBatchesThreads
    - PajePluginPrintSQLCommandsToOutput
    - PajePluginNull
    - PajePluginOutputPJDUMP

- Clean PajeSimulator
  - Create PajePlugin

- Exhaustive list of instrumentations points for the plugins
  - All types and values definitions
  - All create containers
  - Pops
  - Events
  - Add, Sub, Set variables
  - Start and end of links

* 2016-02-28 Starting Aiyra                                            :Tais:
The new implementation with plugins will be called Aiyra.
The code is [[https://github.com/taisbellini/aiyra][here]].
There are only two classes with a print informing which plugin was chosen.

** How to use

#+begin_src sh :results output :session :exports both
java br.ufrgs.inf.tlbellini.PajeGrammar -f <path-to-trace-file> \
                                        -m <comment (optional)> \
                                        -p <plugin (default: null)> \
                                        - ... <options for the specific plugin>
#+end_src

** Plugins available

- "pjdump": it outputs a CSV based on the =pj_dump= format
- "mysql" : saves the data in a MySQL database

** References
Command line reader:
http://www.javaworld.com/article/2074849/core-java/processing-command-line-arguments-in-java--case-closed.html
** Performance
commit: "create poc of integration of plugins and the Options package"
- scorep-cg.A.64.paje - 2.1GB - 367918ms
- scorep-lu.B.64.paje - 776.7MB - 77917ms
- traces-16Mega.paje - 16MB - 1500ms


** Plugins
PajeDumpPlugin: using System.out.println which is bad in performance,
but I couldn't find other solution that would not giva e heap space
problem to big files. The current solution implies the user to decide
how many lines will be in the dump. The higher the number, better the
performance but more memory is used. In my computer, I have
JavaHeapSpace problem. 


* 2016-02-29 Adding PajeInsertDBPlugin                                 :Tais:
** Notes
-When destroy container: just need to insert states
    - Event: inserts when it happens
    - Var: inserts when it is created or updated
    - Link: inserts when it is complete
* 2016-03-15 How to Use 
** DB Plugin 

1) Install MySQL and MySQL Workbench 

2) Create an instance (local or in a server) and choose a name and password to it. Use port 3306. 

3) execute pajeDB.sql script in the created instance.

Now you have a database called "paje". 

Execute the simulator passing the server name (-s) name (-u) and password (-pwd) of the instance you created in step 2. Defaults are "localhost", "root", "root". 


#+begin_src sh :results output :session :exports both
java br.ufrgs.inf.tlbellini.PajeGrammar -f <path-to-trace-file> \
                                        -m <comment (optional)> \
                                        -p mysql \
                                        -s <server-name> \
                                        -u <username> \
                                        -pwd <password> \
#+end_src

** PajeDump Plugin

Execute:

#+begin_src sh :results output :session :exports both
java br.ufrgs.inf.tlbellini.PajeGrammar -f <path-to-trace-file> \
                                        -m <comment (optional)> \
                                        -p pjdump \
                                        -l <lines-per-dump (default: 100000)>
#+end_src

"lines-per-dump" is the number of lines that will be printed each time. Higher numbers takes less time but use more memory. 

* 2016-03-15 - How to Create a Plugin
In order to create a new plugin you'll need to: 
MODIFY OptionsHandler.java in br.ufrgs.inf.tlbellini;
CREATE a NEW class in br.ufrgs.inf.tlbellini.plugins that EXTENDS PajePlugin class. It can also extend any other plugin if they have many similarities. 

MODIFY OptionsHandler:
1) *If your plugin DOES NOT NEED an extra argument, SKIP this instruction*

In the OptionsHandler constructor, add the new argument as follows: 
  
   opt.getSet().addOptions("<alias>", Options.Separator.<SEPARATOR>, Options.Multiplicity.<MULTIPLICITY>);

   <alias> = the alias to identify the argument
   <SEPARATOR> = COLON, EQUALS, BLANK, NONE
   <MULTIPLICITY> = ONCE, ONCE_OR_MORE, ZERO_OR_ONE, ZERO_OR_MORE

2) Explain your new entry (if any) and plugin in printOptionsHelper() method.
3) In pluginHandler() method, add a "case" to your plugin. Make all the assignments you need to do and initialize it. 
   to get the value given for the argument: 
     opt.getSet().getOption("<alias").getResultValue(0)
   to check if the value was set: 
     opt.getSet().isSet("<alias>")
   to initialize:
     PajeGrammar.plugin = new YourPluginClass(...);

CREATE NEW CLASS: 

1) Create a class that extends PajePlugin or any Plugin available. 
   
Instrumentation Points:

